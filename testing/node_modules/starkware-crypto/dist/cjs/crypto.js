"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
const hash_js_1 = __importDefault(require("hash.js"));
const assert_1 = __importDefault(require("assert"));
const RSV = __importStar(require("rsv-signature"));
const bip39 = __importStar(require("bip39"));
const elliptic = __importStar(require("elliptic"));
const encUtils = __importStar(require("enc-utils"));
const js_sha3_1 = require("js-sha3");
const ethereumjs_wallet_1 = require("ethereumjs-wallet");
const constants_1 = require("./constants");
exports.prime = new bn_js_1.default('800000000000011000000000000000000000000000000000000000000000001', 16);
exports.order = new bn_js_1.default('08000000 00000010 ffffffff ffffffff b781126d cae7b232 1e66a241 adc64d2f', 16);
exports.secpOrder = new bn_js_1.default('FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141', 16);
const starkEc = new elliptic.ec(new elliptic.curves.PresetCurve({
    type: 'short',
    prime: null,
    p: exports.prime,
    a: '00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001',
    b: '06f21413 efbe40de 150e596d 72f7a8c5 609ad26c 15c915c1 f4cdfcb9 9cee9e89',
    n: exports.order,
    hash: hash_js_1.default.sha256,
    gRed: false,
    g: constants_1.constantPointsHex[1],
}));
exports.ec = starkEc;
exports.constantPoints = constants_1.constantPointsHex.map((coords) => starkEc.curve.point(new bn_js_1.default(coords[0], 16), new bn_js_1.default(coords[1], 16)));
exports.shiftPoint = exports.constantPoints[0];
const ZERO_BN = new bn_js_1.default('0');
const ONE_BN = new bn_js_1.default('1');
const TWO_POW_22_BN = new bn_js_1.default('400000', 16);
const TWO_POW_31_BN = new bn_js_1.default('80000000', 16);
const TWO_POW_63_BN = new bn_js_1.default('8000000000000000', 16);
const MISSING_HEX_PREFIX = 'Hex strings expected to be prefixed with 0x.';
function isHexPrefixed(str) {
    return str.substring(0, 2) === '0x';
}
function pedersen(input) {
    let point = exports.shiftPoint;
    for (let i = 0; i < input.length; i++) {
        let x = new bn_js_1.default(encUtils.removeHexPrefix(input[i]), 16);
        assert_1.default(x.gte(ZERO_BN) && x.lt(exports.prime), 'Invalid input: ' + input[i]);
        for (let j = 0; j < 252; j++) {
            const pt = exports.constantPoints[2 + i * 252 + j];
            assert_1.default(!point.getX().eq(pt.getX()));
            if (x.and(ONE_BN).toNumber() !== 0) {
                point = point.add(pt);
            }
            x = x.shrn(1);
        }
    }
    return point.getX().toString(16);
}
function isCompressedPublicKey(hex) {
    hex = encUtils.removeHexPrefix(hex);
    return hex.length === 66 && (hex.startsWith('03') || hex.startsWith('02'));
}
function checkHexValue(hex) {
    assert_1.default(isHexPrefixed(hex), MISSING_HEX_PREFIX);
    const hexBn = new bn_js_1.default(encUtils.removeHexPrefix(hex), 16);
    assert_1.default(hexBn.gte(ZERO_BN));
    assert_1.default(hexBn.lt(exports.prime));
}
function parseTokenInput(input) {
    if (typeof input === 'string') {
        if (isCompressedPublicKey(input)) {
            return getXCoordinate(input);
        }
        checkHexValue(input);
        return input;
    }
    return hashTokenId(input);
}
function fixMessage(msg) {
    msg = encUtils.removeHexPrefix(msg);
    msg = new bn_js_1.default(msg, 16).toString(16);
    if (msg.length <= 62) {
        return msg;
    }
    assert_1.default(msg.length === 63);
    return msg + '0';
}
function hashKeyWithIndex(key, index) {
    return new bn_js_1.default(hash_js_1.default
        .sha256()
        .update(encUtils.hexToBuffer(encUtils.removeHexPrefix(key) +
        encUtils.sanitizeBytes(encUtils.numberToHex(index), 2)))
        .digest('hex'), 16);
}
function grindKey(privateKey) {
    let i = 0;
    let key = hashKeyWithIndex(privateKey, i);
    while (!key.lt(exports.secpOrder.sub(exports.secpOrder.mod(exports.order)))) {
        key = hashKeyWithIndex(key.toString(16), i);
        i = i++;
    }
    return key.mod(exports.order).toString('hex');
}
function getIntFromBits(hex, start, end = undefined) {
    let bin = encUtils.hexToBinary(hex);
    let bits = bin.slice(start, end);
    let int = encUtils.binaryToNumber(bits);
    return int;
}
function getAccountPath(layer, application, ethereumAddress, index) {
    const layerHash = hash_js_1.default
        .sha256()
        .update(layer)
        .digest('hex');
    const applicationHash = hash_js_1.default
        .sha256()
        .update(application)
        .digest('hex');
    const layerInt = getIntFromBits(layerHash, -31);
    const applicationInt = getIntFromBits(applicationHash, -31);
    const ethAddressInt1 = getIntFromBits(ethereumAddress, -31);
    const ethAddressInt2 = getIntFromBits(ethereumAddress, -62, -31);
    return `m/2645'/${layerInt}'/${applicationInt}'/${ethAddressInt1}'/${ethAddressInt2}'/${index}`;
}
exports.getAccountPath = getAccountPath;
function getKeyPairFromPath(mnemonic, path) {
    const seed = bip39.mnemonicToSeedSync(mnemonic).toString('hex');
    const privateKey = ethereumjs_wallet_1.hdkey
        .fromMasterSeed(Buffer.from(seed, 'hex'))
        .derivePath(path)
        .getWallet()
        .getPrivateKeyString();
    return getKeyPair(grindKey(privateKey));
}
exports.getKeyPairFromPath = getKeyPairFromPath;
function getKeyPair(privateKey) {
    return starkEc.keyFromPrivate(privateKey, 'hex');
}
exports.getKeyPair = getKeyPair;
function getKeyPairFromPublicKey(publicKey) {
    return starkEc.keyFromPublic(encUtils.hexToArray(publicKey));
}
exports.getKeyPairFromPublicKey = getKeyPairFromPublicKey;
function getPrivate(keyPair) {
    return keyPair.getPrivate('hex');
}
exports.getPrivate = getPrivate;
function getPublic(keyPair, compressed = false) {
    return keyPair.getPublic(compressed, 'hex');
}
exports.getPublic = getPublic;
function getStarkPublicKey(keyPair) {
    return getPublic(keyPair, true);
}
exports.getStarkPublicKey = getStarkPublicKey;
function getXCoordinate(publicKey) {
    const keyPair = getKeyPairFromPublicKey(publicKey);
    return encUtils.sanitizeBytes(keyPair.pub.getX().toString(16), 2);
}
exports.getXCoordinate = getXCoordinate;
function getYCoordinate(publicKey) {
    const keyPair = getKeyPairFromPublicKey(publicKey);
    return encUtils.sanitizeBytes(keyPair.pub.getY().toString(16), 2);
}
exports.getYCoordinate = getYCoordinate;
function hashTokenId(token) {
    let id;
    let tokenAddress;
    switch (token.type.toUpperCase()) {
        case 'ETH':
            id = 'ETH()';
            break;
        case 'ERC20':
            tokenAddress = token.data.tokenAddress;
            checkHexValue(tokenAddress);
            id = `ERC20Token(${tokenAddress})`;
            break;
        case 'ERC721':
            tokenAddress = token.data.tokenAddress;
            checkHexValue(tokenAddress);
            id = `ERC721Token(${tokenAddress})`;
            break;
        default:
            throw new Error(`Unknown token type: ${token.type}`);
    }
    return encUtils.sanitizeHex(js_sha3_1.keccak_256(id).slice(2, 10));
}
exports.hashTokenId = hashTokenId;
function hashMessage(w1, w2, w3) {
    return pedersen([pedersen([w1, w2]), w3]);
}
exports.hashMessage = hashMessage;
function deserializeMessage(serialized) {
    serialized = encUtils.removeHexPrefix(serialized);
    const slice0 = 0;
    const slice1 = slice0 + 1;
    const slice2 = slice1 + 31;
    const slice3 = slice2 + 31;
    const slice4 = slice3 + 63;
    const slice5 = slice4 + 63;
    const slice6 = slice5 + 31;
    const slice7 = slice6 + 22;
    return {
        instructionTypeBn: new bn_js_1.default(serialized.substring(slice0, slice1), 16),
        vault0Bn: new bn_js_1.default(serialized.substring(slice1, slice2), 16),
        vault1Bn: new bn_js_1.default(serialized.substring(slice2, slice3), 16),
        amount0Bn: new bn_js_1.default(serialized.substring(slice3, slice4), 16),
        amount1Bn: new bn_js_1.default(serialized.substring(slice4, slice5), 16),
        nonceBn: new bn_js_1.default(serialized.substring(slice5, slice6), 16),
        expirationTimestampBn: new bn_js_1.default(serialized.substring(slice6, slice7), 16),
    };
}
exports.deserializeMessage = deserializeMessage;
function serializeMessage(instructionTypeBn, vault0Bn, vault1Bn, amount0Bn, amount1Bn, nonceBn, expirationTimestampBn) {
    let serialized = instructionTypeBn;
    serialized = serialized.ushln(31).add(vault0Bn);
    serialized = serialized.ushln(31).add(vault1Bn);
    serialized = serialized.ushln(63).add(amount0Bn);
    serialized = serialized.ushln(63).add(amount1Bn);
    serialized = serialized.ushln(31).add(nonceBn);
    serialized = serialized.ushln(22).add(expirationTimestampBn);
    return encUtils.sanitizeHex(serialized.toString(16));
}
exports.serializeMessage = serializeMessage;
function formatMessage(instruction, vault0, vault1, amount0, amount1, nonce, expirationTimestamp) {
    const isTransfer = instruction === 'transfer';
    const vault0Bn = new bn_js_1.default(vault0);
    const vault1Bn = new bn_js_1.default(vault1);
    const amount0Bn = new bn_js_1.default(amount0, 10);
    const amount1Bn = new bn_js_1.default(amount1, 10);
    const nonceBn = new bn_js_1.default(nonce);
    const expirationTimestampBn = new bn_js_1.default(expirationTimestamp);
    assert_1.default(vault0Bn.gte(ZERO_BN));
    assert_1.default(vault1Bn.gte(ZERO_BN));
    assert_1.default(amount0Bn.gte(ZERO_BN));
    if (!isTransfer) {
        assert_1.default(amount1Bn.gte(ZERO_BN));
    }
    assert_1.default(nonceBn.gte(ZERO_BN));
    assert_1.default(expirationTimestampBn.gte(ZERO_BN));
    assert_1.default(vault0Bn.lt(TWO_POW_31_BN));
    assert_1.default(vault1Bn.lt(TWO_POW_31_BN));
    assert_1.default(amount0Bn.lt(TWO_POW_63_BN));
    assert_1.default(amount1Bn.lt(TWO_POW_63_BN));
    assert_1.default(nonceBn.lt(TWO_POW_31_BN));
    assert_1.default(expirationTimestampBn.lt(TWO_POW_22_BN));
    const instructionTypeBn = isTransfer ? ONE_BN : ZERO_BN;
    return serializeMessage(instructionTypeBn, vault0Bn, vault1Bn, amount0Bn, amount1Bn, nonceBn, expirationTimestampBn);
}
exports.formatMessage = formatMessage;
function getLimitOrderMsg(vaultSell, vaultBuy, amountSell, amountBuy, tokenSell, tokenBuy, nonce, expirationTimestamp) {
    const w1 = parseTokenInput(tokenSell);
    const w2 = parseTokenInput(tokenBuy);
    const w3 = formatMessage('order', vaultSell, vaultBuy, amountSell, amountBuy, nonce, expirationTimestamp);
    return hashMessage(w1, w2, w3);
}
exports.getLimitOrderMsg = getLimitOrderMsg;
function getTransferMsg(amount, nonce, senderVaultId, token, receiverVaultId, receiverPublicKey, expirationTimestamp) {
    const w1 = parseTokenInput(token);
    const w2 = parseTokenInput(receiverPublicKey);
    const w3 = formatMessage('transfer', senderVaultId, receiverVaultId, amount, ZERO_BN.toString(), nonce, expirationTimestamp);
    return hashMessage(w1, w2, w3);
}
exports.getTransferMsg = getTransferMsg;
function sign(keyPair, msg) {
    return keyPair.sign(fixMessage(msg));
}
exports.sign = sign;
function verify(keyPair, msg, sig) {
    return keyPair.verify(fixMessage(msg), sig);
}
exports.verify = verify;
function compress(publicKey) {
    return getKeyPairFromPublicKey(publicKey).getPublic(true, 'hex');
}
exports.compress = compress;
function decompress(publicKey) {
    return getKeyPairFromPublicKey(publicKey).getPublic(false, 'hex');
}
exports.decompress = decompress;
function verifyStarkPublicKey(starkPublicKey, msg, sig) {
    const keyPair = getKeyPairFromPublicKey(starkPublicKey);
    return verify(keyPair, msg, sig);
}
exports.verifyStarkPublicKey = verifyStarkPublicKey;
exports.exportRecoveryParam = RSV.exportRecoveryParam;
exports.importRecoveryParam = RSV.importRecoveryParam;
exports.serializeSignature = RSV.serializeSignature;
exports.deserializeSignature = RSV.deserializeSignature;
//# sourceMappingURL=crypto.js.map